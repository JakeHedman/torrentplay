#! /usr/bin/python
#coding: utf-8

# Requirements:
#   Python packages:
#     - easy_install transmissionrpc
#     - easy_install configobj
#
#   Packages/Apps:
#     - unrar
#     - Transmission with remote access enabled
# 
#   If you use Linux:
#    - mplayer
#    - Python 2.x (Modify hashbang)

# TODO:
# - Settings
#   - Number of simultaneous downloads
#   - Path
# - rtorrent support

from configobj import ConfigObj
import os
import re
import subprocess
import sys
import time
import transmissionrpc

home = os.getenv('USERPROFILE') or os.getenv('HOME')
confpath = "%s/%s" % (home, '.torrentplay')
conf = ConfigObj(
		confpath,
		create_empty = True,
		indent_type = "    ",
		write_empty_values = True,
	)

if len(conf) < 1:
	conf['transmission'] = {
			'port': 9091,
			'username': None,
			'password': None,
		}
	conf['rm_torrent'] = True
	conf['rm_files'] = True
	conf.write()

tc = transmissionrpc.Client(
		port = conf['transmission']['port'],
		user = conf['transmission']['username'],
		password = conf['transmission']['password'],
	)
tpath = os.path.abspath(sys.argv[1])
t = tc.add_torrent(tpath)
if conf.as_bool('rm_torrent'):
	os.unlink(tpath)
t.update()

simultan = 1 # Start downloading 1 at a time
completed = [] # Container for downloaded and extracted rar files

downloading = True # Fake value for first iteration
while downloading:
	try:
		t.update() # Fetch new torrent info	
		# Separate rar files and other files
		rars = []
		misc = []
		for fid in t.files(): # Iterate over file IDs
			f = t.files()[fid]
			f['id'] = fid
			patterns = [
					r"\.rar$",			# .rar
					r"\.[r-t]\d{2}$",	# .r02
				]

			if any([re.search(pattern, f['name']) for pattern in patterns]):
				rars.append(f)
			else:
				misc.append(f)

		# Sort by name
		rars = sorted(rars, key=lambda k: k['name'])

		# Move .rar to beginning of the list
		for key, f in enumerate(rars):
			if f['name'][-4:].lower() == ".rar":
				rars.insert(0, rars.pop(key))
				break
		
		# Check for new finished files
		for i, f in enumerate(rars):
			# Stop when unfinished file is found
			if f['completed'] < f['size']:
				break

			# If new file completed
			if f['name'] not in completed:
				# If the file is the first one
				if i == 0:
					simultan = 2 # Start downloading 2 at a time
					print "Extracting first file %s" % f['name']
					nullw = open('/dev/null', 'w')

					rarpath = "%s/%s" % (tc.session.download_dir, f['name'])
					assert os.path.exists(rarpath)

					# Find name of video file
					cmd = ['unrar', 'vb', rarpath]
					p = subprocess.Popen(cmd, stdout=subprocess.PIPE)
					video_file = p.communicate()[0].strip()
					extension = "".join(video_file.split(".")[-1:])

					# Create and open target
					target_path = "%s/%s.%s" % (tc.session.download_dir, t.name, extension)
					target_write = open(target_path, 'w+')
					cmd = ['unrar', 'p', '-vp', '-inul', rarpath]
					p = subprocess.Popen(cmd, stdout=target_write, stdin=subprocess.PIPE, stderr=nullw)
					
					print "Playing %s" % video_file
					if sys.platform == "darwin":
						subprocess.call(['open', target_path])
					elif "linux" in sys.platform:
						subprocess.call(['mplayer', target_path])
					else:
						exit("Unknown platform, why the face?")
				else:
	#				simultan = 3 # Start downloading 3 at a time
					print "Extracting next file %s" % f['name']
					p.stdin.write("C\n")
				completed.append(f['name'])
		
		queue = rars + misc
		downloading = 0 # Number of ongoing downloads
		new_files = {t.id: {}}

		for f in queue:
			filedict = {
					'priority': 'low',
					'selected': False,
				}

			if f['completed'] < f['size'] and downloading < simultan:
				filedict['selected'] = True
				if downloading == 0:
					filedict['priority'] = 'high'
				downloading += 1
			new_files[t.id][f['id']] = filedict

		tc.set_files(new_files)
	except:
		print "Something went wrong.. trying again"
	time.sleep(1)

print "Done downloading"
p.wait()
print "Done extracting"
if conf.as_bool('rm_files'):
	tc.remove_torrent(t.id, delete_data=True)
